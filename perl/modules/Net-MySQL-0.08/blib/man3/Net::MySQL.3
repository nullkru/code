.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MySQL 3"
.TH MySQL 3 "2003-01-24" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Net::MySQL \- Pure Perl MySQL network protocol interface.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::MySQL;
.Ve
.PP
.Vb 6
\&  my $mysql = Net::MySQL->new(
\&      # hostname => 'mysql.example.jp',   # Default use UNIX socket
\&      database => 'your_database_name',
\&      user     => 'user',
\&      password => 'password'
\&  );
.Ve
.PP
.Vb 5
\&  # INSERT example
\&  $mysql->query(q{
\&      INSERT INTO tablename (first, next) VALUES ('Hello', 'World')
\&  });
\&  printf "Affected row: %d\en", $mysql->get_affected_rows_length;
.Ve
.PP
.Vb 8
\&  # SLECT example
\&  $mysql->query(q{SELECT * FROM tablename});
\&  my $record_set = $mysql->create_record_iterator;
\&  while (my $record = $record_set->each) {
\&      printf "First column: %s Next column: %s\en",
\&          $record->[0], $record->[1];
\&  }
\&  $mysql->close;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::MySQL is a Pure Perl client interface for the MySQL database. This module implements network protocol between server and client of MySQL, thus you don't need external MySQL client library like libmysqlclient for this module to work. It means this module enables you to connect to MySQL server from some operation systems which MySQL is not ported. How nifty!
.PP
Since this module's final goal is to completely replace DBD::mysql, \s-1API\s0 is made similar to that of \s-1DBI\s0.
.PP
From perl you activate the interface with the statement
.PP
.Vb 1
\&    use Net::MySQL;
.Ve
.PP
After that you can connect to multiple MySQL daemon and send multiple queries to any of them via a simple object oriented interface.
.PP
There are two classes which have public APIs: Net::MySQL and Net::MySQL::RecordIterator.
.PP
.Vb 6
\&    $mysql = Net::MySQL->new(
\&        hostname => $host,
\&        database => $database,
\&        user     => $user,
\&        password => $password,
\&    );
.Ve
.PP
Once you have connected to a daemon, you can can execute \s-1SQL\s0 with:
.PP
.Vb 3
\&    $mysql->query(q{
\&        INSERT INTO foo (id, message) VALUES (1, 'Hello World')
\&    });
.Ve
.PP
If you want to retrieve results, you need to create a so-called statement handle with:
.PP
.Vb 7
\&    $mysql->query(q{
\&        SELECT id, message FROM foo
\&    });
\&    if ($mysql->has_selected_record) {
\&        my $a_record_iterator = $mysql->create_record_iterator;
\&        # ...
\&    }
.Ve
.PP
This Net::MySQL::RecordIterator object can be used for multiple purposes. First of all you can retreive a row of data:
.PP
.Vb 1
\&    my $record = $a_record_iterator->each;
.Ve
.PP
The \fIeach()\fR method takes out the reference result of one line at a time, and the return value is \s-1ARRAY\s0 reference.
.Sh "Net::MySQL \s-1API\s0"
.IX Subsection "Net::MySQL API"
.IP "new(\s-1HASH\s0)" 4
.IX Item "new(HASH)"
.Vb 2
\&    use Net::MySQL;
\&    use strict;
.Ve
.Sp
.Vb 7
\&    my $mysql = Net::MySQL->new(
\&        unixsocket => $path_to_socket,
\&        hostname   => $host,
\&        database   => $database,
\&        user       => $user,
\&        password   => $password,
\&    );
.Ve
.Sp
The constructor of Net::MySQL. Connection with MySQL daemon is established and the object is returned. Argument hash contains following parameters:
.RS 4
.IP "unixsocket" 8
.IX Item "unixsocket"
Path of the \s-1UNIX\s0 socket where MySQL daemon. default is \fI/tmp/mysql.sock\fR.
Supposing \fIhostname\fR is omitted, it will connect by \fI\s-1UNIX\s0 Socket\fR.
.IP "hostname" 8
.IX Item "hostname"
Name of the host where MySQL daemon runs.
Supposing \fIhostname\fR is specified, it will connect by \fI\s-1INET\s0 Socket\fR.
.IP "port" 8
.IX Item "port"
Port where MySQL daemon listens to. default is 3306.
.IP "database" 8
.IX Item "database"
Name of the database to connect.
.IP "user / password" 8
.IX Item "user / password"
Username and password for database authentication.
.IP "timeout" 8
.IX Item "timeout"
The waiting time which carries out a timeout when connection is overdue is specified.
.IP "debug" 8
.IX Item "debug"
The exchanged packet will be outputted if a true value is given.
.RE
.RS 4
.RE
.IP "create_database(\s-1DB_NAME\s0)" 4
.IX Item "create_database(DB_NAME)"
A \fIcreate_DATABASE()\fR method creates a database by the specified name.
.Sp
.Vb 2
\&    $mysql->create_database('example_db');
\&    die $mysql->get_error_message if $mysql->is_error;
.Ve
.IP "drop_database(\s-1DB_NAME\s0)" 4
.IX Item "drop_database(DB_NAME)"
A \fIdrop_database()\fR method deletes the database of the specified name.
.Sp
.Vb 2
\&    $mysql->drop_database('example_db');
\&    die $mysql->get_error_message if $mysql->is_error;
.Ve
.IP "query(\s-1SQL_STRING\s0)" 4
.IX Item "query(SQL_STRING)"
A \fIquery()\fR method transmits the specified \s-1SQL\s0 string to MySQL database, and obtains the response.
.IP "\fIcreate_record_iterator()\fR" 4
.IX Item "create_record_iterator()"
When \s-1SELECT\s0 type \s-1SQL\s0 is specified, Net::MySQL::RecordIterator object which shows the reference result is returned.
.Sp
.Vb 2
\&    $mysql->query(q{SELECT * FROM table});
\&    my $a_record_iterator = $mysql->create_recrod_iterator();
.Ve
.Sp
Net::MySQL::RecordIterator object is applicable to acquisition of a reference result. See \*(L"/Net::SQL::RecordIterator \s-1API\s0\*(R" for more.
.IP "\fIget_affected_rows_length()\fR" 4
.IX Item "get_affected_rows_length()"
returns the number of records finally influenced by specified \s-1SQL\s0.
.Sp
.Vb 1
\&    my $affected_rows = $mysql->get_affected_rows_length;
.Ve
.IP "\fIget_insert_id()\fR" 4
.IX Item "get_insert_id()"
MySQL has the ability to choose unique key values automatically. If this happened, the new \s-1ID\s0 will be stored in this attribute. 
.IP "\fIis_error()\fR" 4
.IX Item "is_error()"
\&\s-1TRUE\s0 will be returned if the error has occurred.
.IP "\fIhas_selected_record()\fR" 4
.IX Item "has_selected_record()"
\&\s-1TRUE\s0 will be returned if it has a reference result by \s-1SELECT\s0.
.IP "\fIget_field_length()\fR" 4
.IX Item "get_field_length()"
return the number of column.
.IP "\fIget_field_names()\fR" 4
.IX Item "get_field_names()"
return column names by \s-1ARRAY\s0.
.IP "\fIclose()\fR" 4
.IX Item "close()"
transmits an end message to MySQL daemon, and closes a socket.
.Sh "Net::MySQL::RecordIterator \s-1API\s0"
.IX Subsection "Net::MySQL::RecordIterator API"
Net::MySQL::RecordIterator object is generated by the \fIquery()\fR method of Net::MySQL object. Thus it has no public constructor method.
.IP "\fIeach()\fR" 4
.IX Item "each()"
\&\fIeach()\fR method takes out only one line from a result, and returns it as an \s-1ARRAY\s0 reference. \f(CW\*(C`undef\*(C'\fR is returned when all the lines has been taken out.
.Sp
.Vb 4
\&    while (my $record = $a_record_iterator->each) {
\&        printf "Column 1: %s Column 2: %s Collumn 3: %s\en",
\&            $record->[0], $record->[1], $record->[2];
\&    }
.Ve
.SH "SUPPORT OPERATING SYSTEM"
.IX Header "SUPPORT OPERATING SYSTEM"
This module has been tested on these OSes.
.IP "* MacOS 9.x" 4
.IX Item "MacOS 9.x"
with MacPerl5.6.1r.
.IP "* MacOS X" 4
.IX Item "MacOS X"
with perl5.6.0 build for darwin.
.IP "* Windows2000" 4
.IX Item "Windows2000"
with ActivePerl5.6.1 build631.
.IP "* FreeBSD 3.4 and 4.x" 4
.IX Item "FreeBSD 3.4 and 4.x"
with perl5.6.1 build for i386\-freebsd.
.Sp
with perl5.005_03 build for i386\-freebsd.
.IP "* Linux" 4
.IX Item "Linux"
with perl 5.005_03 built for ppc\-linux.
.Sp
with perl 5.6.0 bult for i386\-linux.
.IP "* Solaris 2.6 (\s-1SPARC\s0)" 4
.IX Item "Solaris 2.6 (SPARC)"
with perl 5.6.1 built for sun4\-solaris.
.Sp
with perl 5.004_04 built for sun4\-solaris.
.Sp
Can use on Solaris2.6 with perl5.004_04, although \fImake test\fR is failure.
.PP
This list is the environment which I can use by the test usually. Net::MySQL will operate  also in much environment which is not in a list.
.PP
I believe this module can work with whatever perls which has \fBIO::Socket\fR. I'll be glad if you give me a report of successful installation of this module on \fIrare\fR OSes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
libmysql, IO::Socket
.SH "AUTHOR"
.IX Header "AUTHOR"
Hiroyuki \s-1OYAMA\s0 <oyama@module.jp>
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
Copyright (C) 2002 Hiroyuki \s-1OYAMA\s0. Japan. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
